# %%
"""
# Cryptography

#### fixme todo: introduce cryptography

- Make a new file called w1d1.py, and copy the code snippets from this file into it as you are progressing through the instructions.
- For the sake of the exercise, aim for correctness, not efficiency.

<!-- toc -->

# 1. Stream Ciphers and Pseudorandom Generators

In this exercise, you'll learn about one of the simplest forms of encryption: stream ciphers. You will implement a Linear Congruential Generator (LCG) to generate a keystream, use it to encrypt and decrypt messages, and finally break the cipher using a technique called crib-dragging.

## Introduction

Stream ciphers are a type of symmetric encryption algorithm that encrypt data one bit or byte at a time, rather than in fixed-size blocks like block ciphers.
They work by generating a pseudorandom keystream that is as long as the plaintext message, then combining this keystream with the plaintext using a simple operation like XOR.
The security of a stream cipher depends entirely on the unpredictability of the keystream - if an attacker can predict the keystream, they can decrypt the message.
Stream ciphers are particularly useful for applications where data arrives in a continuous stream or where low latency is important, such as in real-time communications.

Linear Congruential Generators (LCGs) are one of the oldest and simplest types of pseudorandom number generators, following the recurrence relation: X(n+1) = (a Ã— X(n) + c) mod m, where X is the sequence of pseudorandom values, and a, c, and m are carefully chosen constants.
While LCGs are fast and easy to implement, they have significant weaknesses that make them unsuitable for cryptographic purposes.
Their output is highly predictable - knowing just a few consecutive outputs allows an attacker to determine the internal state and predict all future outputs.
Additionally, LCGs exhibit strong correlations in higher dimensions and have relatively short periods compared to modern generators.
Despite these cryptographic weaknesses, LCGs remain useful for non-security applications like simulations and games where speed is more important than cryptographic strength.
In cryptography, more sophisticated generators like stream ciphers based on block ciphers or dedicated constructions are used instead.

This exercise will guide you through implementing a simple stream cipher using an LCG, recovering the internal state from a few bytes of the keystream, and breaking stream ciphers where the same key is reused via crib-dragging.

## Content & Learning Objectives

### 1ï¸âƒ£ Linear Congruential Generators

In the first exercise, you'll implement an LCG, one of the simplest pseudorandom number generators.

> **Learning Objectives**
> - Understand the mathematical foundation of pseudorandom number generators
> - Implement an LCG and use it to generate a keystream

### 2ï¸âƒ£ Building a Stream Cipher

Here, you'll use the keystream generated by the LCG to build a simple stream cipher that can encrypt and decrypt messages.

> **Learning Objectives**
> - Implement a stream ciphers work using XOR operations
> - Explore the security implications of key reuse

### 3ï¸âƒ£ Breaking a Stream Cipher

In the final exercise, you'll learn how to break a stream cipher using a technique called crib-dragging. This will help you understand the vulnerabilities of stream ciphers when keys are reused.

> **Learning Objectives**
> - Understand the vulnerabilities of stream ciphers
> - Implement a crib-dragging attack to recover plaintext from ciphertext

### Key Properties of Secure Stream Ciphers

1. **Pseudorandomness**: The keystream should be indistinguishable from random (i.e., no patterns the attacker can predict)
2. **Long period**: The keystream shouldn't repeat for practical message lengths
3. **Key sensitivity**: Small changes in the key should produce completely different keystreams
4. **Forward secrecy**: Knowledge of some keystream bits shouldn't reveal others

<details>
<summary>Vocabulary: Cryptographic Terms</summary>

- **PRNG (Pseudorandom Number Generator)**: An algorithm that produces a sequence of numbers that appears random but is actually deterministic given an initial seed
- **Keystream**: The sequence of pseudorandom bytes generated by a stream cipher that gets XORed with the plaintext
- **One-time pad**: A theoretically unbreakable cipher where the key is truly random, as long as the message, and never reused
- **TLS (Transport Layer Security)**: The protocol that secures HTTPS connections
- **WPA2**: A security protocol for WiFi networks
- **Forward secrecy**: A property where compromise of long-term keys doesn't compromise past session keys

</details>
"""


# %%
"""
## Exercise 1.1: Implementing a Linear Congruential Generator (LCG)

An LCG generates a sequence of numbers using the recurrence relation:
```
X_{n+1} = (a * X_n + c) mod m
```

Where:
- X_n is the current state
- a is the multiplier
- c is the increment
- m is the modulus

We'll use the parameters from Numerical Recipes (a popular choice):
- a = 1664525
- c = 1013904223
- m = 2^32

<details>
<summary>Vocabulary: LCG Terms</summary>

- **Recurrence relation**: A formula that defines each term of a sequence using previous terms
- **Modulus (m)**: The value that wraps the sequence around (like a clock with m positions)
- **Multiplier (a)**: Scales the current value before adding the increment
- **Increment (c)**: Added to ensure the sequence doesn't get stuck at zero
- **Period**: How many values the generator produces before repeating

</details>

### Exercise - implement lcg_keystream

> **Difficulty**: ðŸ”´âšªâšªâšªâšª  
> **Importance**: ðŸ”µðŸ”µðŸ”µâšªâšª
> 
> You should spend up to ~10 minutes on this exercise.

Implement the `lcg_keystream` function that generates a stream of bytes using the LCG algorithm.
"""

from typing import Generator

def lcg_keystream(seed: int) -> Generator[int, None, None]:
    """
    Generate an infinite keystream using a basic LCG.

    The LCG formula is: next_state = (a * current_state + c) mod m
    Where:
        - a = 1664525
        - c = 1013904223
        - m = 2^32

    Args:
        seed: Initial seed value for the generator.

    Yields:
        Bytes of the keystream as integers in range 0-255.
    """
    if "SOLUTION":
        a = 1664525
        c = 1013904223
        m = 2 ** 32
        state = seed
        while True:
            state = (a * state + c) % m
            yield state & 0xFF  # Extract lowest 8 bits as a byte
    else:
        # TODO: Implement the LCG keystream generator
        #    - Update state using the LCG formula
        #    - Yield the lowest 8 bits of state as a byte
        pass


def test_lcg_keystream(lcg_keystream):
    """Test the LCG keystream generator."""
    print("Testing LCG keystream...")

    # Test 1: Basic functionality
    ks = lcg_keystream(1)
    first_five = [next(ks) for _ in range(5)]
    print(f"First 5 bytes: {first_five}")
    assert first_five == [108, 219, 126, 197, 96], "First five bytes do not match expected values"

    # Test 2: Deterministic output
    ks2 = lcg_keystream(1)
    second_five = [next(ks2) for _ in range(5)]
    assert first_five == second_five, "Keystream should be deterministic for the same seed"

    print("âœ“ LCG keystream tests passed!\n" + "=" * 60)
test_lcg_keystream(lcg_keystream)
# %%
"""
## Exercise 1.2: Building a Stream Cipher

Stream ciphers work by XORing the plaintext with a keystream. The encryption process is:
```
ciphertext[i] = plaintext[i] XOR keystream[i]
```

Decryption is identical:
```
plaintext[i] = ciphertext[i] XOR keystream[i]
```

This works because: `(A XOR B) XOR B = A XOR (B XOR B) = A XOR 0 = A`

<details>
<summary>Vocabulary: XOR Operation</summary>

- **XOR (Exclusive OR)**: A bitwise operation that outputs 1 when inputs differ and 0 when they're the same. Key properties:
  - `A XOR A = 0` (anything XORed with itself is zero)
  - `A XOR 0 = A` (XORing with zero leaves value unchanged)
  - `A XOR B = B XOR A` (commutative)
  - `(A XOR B) XOR B = A` (self-inverse property - crucial for stream ciphers!)

</details>

### Exercise - implement encrypt and decrypt

> **Difficulty**: ðŸ”´ðŸ”´âšªâšªâšª  
> **Importance**: ðŸ”µðŸ”µðŸ”µðŸ”µâšª
> 
> You should spend up to ~10 minutes on this exercise.

Implement the `encrypt` and `decrypt` functions using your LCG keystream.
"""


def lcg_encrypt(seed: int, plaintext: bytes) -> bytes:
    """
    Encrypt plaintext using the LCG keystream.

    Stream cipher encryption: ciphertext = plaintext XOR keystream

    Args:
        seed: Seed for the keystream generator.
        plaintext: Data to encrypt.

    Returns:
        Ciphertext as bytes.
    """
    if "SOLUTION":
        ks = lcg_keystream(seed)
        return bytes(b ^ next(ks) for b in plaintext)
    else:
        # TODO: Implement stream cipher encryption
        #   - XOR each byte of plaintext with the bytes from lcg_keystream
        #   - return the resulting ciphertext as bytes
        pass

def test_encrypt(encrypt):
    """Test the encrypt function."""
    print("Testing encrypt function...")

    # Test 1: Basic encryption
    seed = 12345
    plaintext = b"Hello, World!"
    ciphertext = encrypt(seed, plaintext)
    print([hex(b) for b in ciphertext])
    assert ciphertext == bytes([0x0c, 0xb6, 0x7a, 0x11, 0xd7, 0x9b, 0x8a, 0x56, 0x03, 0xa9, 0x12, 0xa1, 0x41]), "Encryption output does not match expected"
    print("âœ“ Tests for encrypt function passed!\n" + "=" * 60)
test_encrypt(lcg_encrypt)

# %%
def lcg_decrypt(seed: int, ciphertext: bytes) -> bytes:
    """
    Decrypt ciphertext using the same LCG keystream.

    In stream ciphers, decryption is the same operation as encryption!

    Args:
        seed: Seed for the keystream generator.
        ciphertext: Data to decrypt.

    Returns:
        Decrypted plaintext.
    """
    if "SOLUTION":
        return lcg_encrypt(seed, ciphertext)
    else:
        # TODO: Implement stream cipher decryption
        pass

def test_decrypt(decrypt):
    """Test the decrypt function."""
    print("Testing decrypt function...")

    # Test 1: Basic decryption
    seed = 12345
    ciphertext = bytes([0x0c, 0xb6, 0x7a, 0x11, 0xd7, 0x9b, 0x8a, 0x56, 0x03, 0xa9, 0x12, 0xa1, 0x41])
    plaintext = decrypt(seed, ciphertext)
    assert plaintext == b"Hello, World!", "Decryption output does not match expected"
    print("âœ“ Tests for decrypt function passed!\n" + "=" * 60)
test_decrypt(lcg_decrypt)
# %%

def test_stream_cipher(lcg_keystream, encrypt, decrypt):
    """Test the stream cipher implementation."""
    print("Testing stream cipher implementation...")

    # Test 1: Basic encryption/decryption
    seed = 12345
    plaintext = b"Hello, World!"
    ciphertext = encrypt(seed, plaintext)
    decrypted = decrypt(seed, ciphertext)

    print(f"Plaintext:  {plaintext}")
    print(f"Ciphertext: {ciphertext.hex()}")
    print(f"Decrypted:  {decrypted}")
    print(f"âœ“ Decryption works: {decrypted == plaintext}")

    # Test 2: Different seeds produce different ciphertexts
    ciphertext2 = encrypt(seed + 1, plaintext)
    print(f"\nâœ“ Different seeds produce different output: {ciphertext != ciphertext2}")

    # Test 3: Same seed produces same keystream
    ct1 = encrypt(seed, b"Test message")
    ct2 = encrypt(seed, b"Test message")
    print(f"âœ“ Deterministic (same seed â†’ same output): {ct1 == ct2}")

    # Test 4: Stream property (can encrypt byte by byte)
    full_ct = encrypt(seed, b"ABCD")
    ks = lcg_keystream(seed)
    byte_ct = bytes([b ^ next(ks) for b in b"ABCD"])
    print(f"âœ“ Stream property holds: {full_ct == byte_ct}")

    print("\n" + "=" * 60)


test_stream_cipher(lcg_keystream, lcg_encrypt, lcg_decrypt)

# %%
"""
## Stream Cipher Security

Now that you've built a stream cipher, let's explore its security properties and weaknesses.

### Why LCG is Not Cryptographically Secure

While our LCG-based stream cipher works, it's not secure for cryptographic use:

1. **Predictability**: Given a few outputs, the entire sequence can be predicted - we'll do this in the next exercise!
2. **Short period**: Will repeat after at most 2^32 outputs
3. **Statistical bias**: Even a small amount of bias can be used to decrease the search space for brute-force attacks
4. **State recovery**: The internal state can be recovered from outputs

### Real Cryptographic Stream Ciphers

Modern stream ciphers like ChaCha20 address these issues:
- Use complex non-linear operations
- Have much larger internal states
- Resist known cryptanalytic attacks
- Pass stringent randomness tests

### The Importance of Key Reuse

One critical vulnerability in stream ciphers is key reuse. If the same key (seed) is used to encrypt two different messages:

```
C1 = M1 XOR Keystream
C2 = M2 XOR Keystream

Then: C1 XOR C2 = M1 XOR M2
```

This reveals the XOR of the two plaintexts, which can be used to recover both messages!

<details>
<summary>Vocabulary: Key Reuse Attack</summary>

- **Two-time pad**: When a one-time pad (or stream cipher key) is used twice - a critical security failure
- **Crib dragging**: A technique to recover plaintexts when you have `M1 XOR M2` by guessing common words
- **Known plaintext attack**: When an attacker knows some plaintext-ciphertext pairs
- **Malleability**: The property that allows an attacker to modify ciphertexts in predictable ways

</details>

### Next Steps

In practice, you would:
1. Use cryptographically secure PRNGs (like those in `secrets` module)
2. Never reuse keys/nonces in stream ciphers
3. Consider authenticated encryption modes
4. Use well-vetted algorithms like ChaCha20 or AES-CTR

Understanding these basic principles helps you appreciate why cryptographic primitives are designed the way they are!

<details>
<summary>Vocabulary: More Cryptography Terms</summary>

- **Nonce**: A "number used once" - a value that should never be repeated with the same key. Critical for stream cipher security
- **Authenticated encryption**: Encryption that also provides integrity checking to detect tampering
- **ChaCha20**: A modern stream cipher designed by Daniel Bernstein, used in TLS 1.3
- **AES-CTR**: AES (Advanced Encryption Standard) in Counter mode, which turns the block cipher into a stream cipher
- **Initialization Vector (IV)**: Similar to a nonce, used to ensure same plaintext encrypts differently each time

</details>
"""
# %%
"""
## Exercise 1.3: Breaking Stream Ciphers with Crib-Dragging

When a stream cipher key is reused, it becomes vulnerable to a **crib-dragging attack**. If we have two ciphertexts encrypted with the same keystream:

```
C1 = M1 XOR K
C2 = M2 XOR K
```

Then: `C1 XOR C2 = M1 XOR M2`

If we guess (or "crib") part of one message, we can recover the corresponding part of the other message!

<details>
<summary>How Crib-Dragging Works</summary>

1. We XOR the two ciphertexts to get `M1 XOR M2`
2. We guess a word or phrase that might appear in one message (the "crib")
3. We XOR this crib at different positions in `M1 XOR M2`
4. When we find the right position, we'll see readable text from the other message
5. This reveals parts of both plaintexts, which can help us guess more

</details>

### Exercise 1.3a: LCG State Recovery

First, let's understand how to recover the LCG seed from known keystream bytes.

> **Difficulty**: ðŸ”´ðŸ”´ðŸ”´âšªâšª  
> **Importance**: ðŸ”µðŸ”µðŸ”µðŸ”µâšª
> 
> You should spend up to ~15 minutes on this exercise.

Implement the `recover_lcg_state` function that recovers the seed from consecutive keystream bytes.
"""


def recover_lcg_state(keystream_bytes: list[int]) -> int:
    """
    Recover the LCG seed from consecutive keystream bytes.

    The key insight is that we observe the OUTPUT of states, not the states themselves.
    If we see byte b0, that was produced by some state s0.
    We need to find s_{-1} (the seed) such that s0 = (a * s_{-1} + c) % m and s0 & 0xFF = b0.

    Args:
        keystream_bytes: At least 2 consecutive bytes from the keystream.

    Returns:
        A seed (initial state) that generates this keystream.
    """
    if len(keystream_bytes) < 2:
        raise ValueError("Need at least 2 keystream bytes")

    a = 1664525
    c = 1013904223
    m = 2 ** 32

    if "SOLUTION":
        # For each possible value of the state that produced the first byte
        for upper_24_bits in range(2 ** 24):
            # The state that produced keystream_bytes[0] has lower 8 bits = keystream_bytes[0]
            state_0 = (upper_24_bits << 8) | keystream_bytes[0]

            # Check if this state produces the subsequent bytes correctly
            state = state_0
            valid = True

            for i in range(1, len(keystream_bytes)):
                state = (a * state + c) % m
                if (state & 0xFF) != keystream_bytes[i]:
                    valid = False
                    break

            if valid:
                # We found the state that produced the first byte
                # Now find the seed (previous state)
                # We need to solve: state_0 = (a * seed + c) % m
                # This gives us: seed = (state_0 - c) * a^{-1} mod m

                # Calculate modular inverse of a modulo m
                a_inv = pow(a, -1, m)
                seed = ((state_0 - c) * a_inv) % m
                return seed

        raise ValueError("Could not recover state")
    else:
        # TODO: Implement LCG state recovery
        #   - brute-force through all possible upper 24 bits - this will let you try all possible starting states
        #   - for each state, check if it produces the correct bytes
        #   - if it does, calculate the seed by rearranging the LCG formula to get a formula for the seed

        # Hints:
        # 1. For each possible upper 24 bits (2^24 possibilities)
        # 2. Construct state_0 = (upper_24_bits << 8) | keystream_bytes[0]
        # 3. Check if this state produces the correct subsequent bytes
        # 4. If valid, calculate the seed using modular arithmetic
        pass


def test_lcg_state_recovery(lcg_keystream, recover_lcg_state):
    """Test LCG state recovery."""
    print("Testing LCG state recovery...")

    # Generate some keystream bytes
    seed = 12345678
    ks = lcg_keystream(seed)
    bytes_observed = [next(ks) for _ in range(5)]
    print(f"Observed keystream bytes: {bytes_observed}")

    # Recover the seed
    recovered_seed = recover_lcg_state(bytes_observed)
    print(f"Original seed: {seed}")
    print(f"Recovered seed: {recovered_seed}")

    # Verify it produces the same keystream
    ks_test = lcg_keystream(recovered_seed)
    bytes_test = [next(ks_test) for _ in range(5)]
    assert bytes_test == bytes_observed, "Recovered seed doesn't produce same keystream"

    print("âœ“ LCG state recovery successful!\n" + "=" * 60)


test_lcg_state_recovery(lcg_keystream, recover_lcg_state)

# %%
"""
### Exercise 1.3b: The Crib-Dragging Attack

Now let's perform a real crib-dragging attack. We have intercepted two messages encrypted with the same key. It looks like the messages are talking about LCGs and stream ciphers, so you can safely assume that the phrase "linear congruential generator" appears in one of them.
"""

# Two paragraphs about LCGs, one containing our crib
try:
    #  Fixme: we should figure out imports
    from w1d1.stream_cipher_secrets import intercept_messages
except ImportError:
    from stream_cipher_secrets import intercept_messages
ciphertext1, ciphertext2 = intercept_messages(lcg_encrypt)
print(f"Intercepted ciphertext 1 ({len(ciphertext1)} bytes): {ciphertext1[:50].hex()}...")
print(f"Intercepted ciphertext 2 ({len(ciphertext2)} bytes): {ciphertext2[:50].hex()}...")

# %%
"""
### Exercise - implement crib_drag

> **Difficulty**: ðŸ”´ðŸ”´ðŸ”´ðŸ”´âšª  
> **Importance**: ðŸ”µðŸ”µðŸ”µðŸ”µðŸ”µ
> 
> You should spend up to ~20 minutes on this exercise.

Implement the `crib_drag` function that tries a known plaintext fragment at different positions.
"""


def crib_drag(ciphertext1: bytes, ciphertext2: bytes, crib: bytes) -> list[tuple[int, bytes]]:
    """
    Perform crib-dragging attack on two ciphertexts encrypted with the same keystream.

    Args:
        ciphertext1: First intercepted ciphertext
        ciphertext2: Second intercepted ciphertext
        crib: Known plaintext fragment to try

    Returns:
        List of (position, recovered_text) tuples for further analysis.
    """
    if "SOLUTION":
        # Calculate M1 XOR M2
        xor_texts = bytes(c1 ^ c2 for c1, c2 in zip(ciphertext1, ciphertext2))

        results = []

        # Try the crib at each possible position
        for pos in range(len(xor_texts) - len(crib) + 1):
            # XOR the crib with M1 XOR M2 at this position
            recovered = bytes(crib[i] ^ xor_texts[pos + i] for i in range(len(crib)))

            # Check if the recovered text looks readable (simple heuristic)
            results.append((pos, recovered))

        return results
    else:
        # TODO: Implement crib-dragging
        #   - Use the xor_texts = C1 XOR C2 to find M1 XOR M2
        #   - For each position in xor_texts, XOR the crib with the text at that position
        #   - return a list of tuples (position, recovered_text)

        # Hint:
        # 1. Calculate xor_texts = C1 XOR C2 (which equals M1 XOR M2)
        # 2. For each position from 0 to len(xor_texts) - len(crib):
        #    a. XOR the crib with xor_texts at this position
        #    b. Check if result is readable (all bytes are printable ASCII: 32-126)
        #    c. If readable, add (position, recovered_text) to results
        # 3. Return results list
        pass


def test_crib_drag(crib_drag, ciphertext1, ciphertext2):
    """Test the crib-dragging attack."""
    print("Testing crib-dragging attack...")

    # The crib we'll use - we suspect this phrase appears in one of the messages
    crib = b"linear congruential generator"

    # Perform the attack
    results = crib_drag(ciphertext1, ciphertext2, crib)[:10]  # Limit to first 10 results for brevity

    print(f"\nTrying crib: '{crib.decode()}'")
    print(f"Found {len(results)} potential matches:\n")

    for pos, recovered in results:
        print(f"Position {pos}: '{recovered.decode()}'")

    # The correct position should reveal part of message2
    assert len(results) > 0, "No matches found - check your implementation"

    # Find the most likely match (usually the one that makes most sense)
    correct_pos = 2  # This is where "linear congruential generator" appears in message1

    print(f"\nâœ“ The crib appears to be at position {correct_pos}!")
    print("This reveals part of the other message.\n" + "=" * 60)

    return correct_pos


correct_position = test_crib_drag(crib_drag, ciphertext1, ciphertext2)

# %%
"""
### Exercise 1.3c: Full Message Recovery

Now that we've found where the crib appears, we can:
1. Recover part of the keystream at that position
2. Find the LCG state that produced those keystream bytes
3. Reverse the LCG to find the original seed
4. Decrypt both messages completely!

The key insight: if we know keystream bytes at position P, we can find the state that 
produced them, then reverse the LCG P times to get back to the original seed.

### Exercise - implement recover_seed

> **Difficulty**: ðŸ”´ðŸ”´ðŸ”´ðŸ”´âšª  
> **Importance**: ðŸ”µðŸ”µðŸ”µðŸ”µðŸ”µ
> 
> You should spend up to ~15 minutes on this exercise.

First, implement `recover_seed` that finds the original seed from a known plaintext at a specific position.
"""


def recover_seed(ciphertext: bytes, known_plaintext: bytes, position: int) -> int:
    """
    Recover the original LCG seed from a known plaintext fragment at a specific position.

    This function recovers keystream bytes at the given position, finds the LCG state
    that produced them, then reverses the LCG to find the original seed.

    Args:
        ciphertext: The ciphertext containing the known plaintext
        known_plaintext: The known plaintext fragment
        position: The position where known_plaintext appears in the original message

    Returns:
        The original seed used to encrypt the message
    """
    if "SOLUTION":
        # Step 1: Recover keystream bytes at the known position
        keystream_at_position = [
            ciphertext[position + i] ^ known_plaintext[i]
            for i in range(len(known_plaintext))
        ]


        # Step 2: Use recover_lcg_state to find the seed that would produce these bytes
        # if they were at the start of the keystream
        seed_for_position = recover_lcg_state(keystream_at_position)

        # Step 3: This seed produces our bytes immediately, but in the actual encryption
        # these bytes appear after 'position' iterations. So we need to reverse the LCG
        # 'position' times to find the original seed.

        a = 1664525
        c = 1013904223
        m = 2 ** 32
        a_inv = pow(a, -1, m)

        # Reverse the LCG 'position' times
        state = seed_for_position
        for _ in range(position):
            state = ((state - c) * a_inv) % m

        print(f"Found original seed: {state}")

        return state
    else:
        # TODO: Implement seed recovery
        #   - Use the known plaintext to recover keystream bytes at the given position
        #   - Call recover_lcg_state(keystream_bytes) to get the seed that produces these bytes
        #   - note that the seed at this position is the same as the state - so you can reverse the LCG 'position' times to get back to the original seed
        #
        # Hints:
        # 1. Recover keystream bytes at position:
        #    keystream[i] = ciphertext[position+i] XOR known_plaintext[i]
        # 2. Call recover_lcg_state(keystream) to get the seed that produces these bytes
        # 3. Reverse the LCG 'position' times to get back to the original seed:
        #    - a_inv = pow(a, -1, m)
        #    - state = ((state - c) * a_inv) % m
        # 4. Return the original seed
        pass


def test_recover_seed(recover_seed, decrypt, ciphertext1, correct_position):
    """Test seed recovery."""
    print("Testing seed recovery...")

    # Use our known crib and position
    recovered = recover_seed(ciphertext1, b"linear congruential generator", correct_position)
    print(f"Recovered seed: {recovered}")

    # Verify by decrypting
    test_msg = decrypt(recovered, ciphertext1)
    print(f"Recovered message: {test_msg.decode()[:50]}...")
    assert b"linear congruential generator" in test_msg, "Seed recovery failed"

    print("âœ“ Seed recovery successful!\n" + "=" * 60)


test_recover_seed(recover_seed, lcg_decrypt, ciphertext1, correct_position)

# %%
"""
### Exercise - implement recover_messages

> **Difficulty**: ðŸ”´ðŸ”´ðŸ”´âšªâšª  
> **Importance**: ðŸ”µðŸ”µðŸ”µðŸ”µðŸ”µ
> 
> You should spend up to ~10 minutes on this exercise.

Now implement `recover_messages` that uses `recover_seed` to decrypt both messages.
"""


def recover_messages(ciphertext1: bytes, ciphertext2: bytes,
                     known_plaintext: bytes, position: int) -> tuple[bytes, bytes]:
    """
    Recover both messages using a known plaintext fragment.

    Args:
        ciphertext1: First ciphertext (contains known_plaintext)
        ciphertext2: Second ciphertext
        known_plaintext: Known fragment from message1
        position: Position of known_plaintext in message1

    Returns:
        Tuple of (recovered_message1, recovered_message2)
    """
    if "SOLUTION":
        try:
            # Use recover_seed to get the original seed
            seed = recover_seed(ciphertext1, known_plaintext, position)

            print(f"Using recovered seed: {seed}")

            # Decrypt both messages
            msg1 = decrypt(seed, ciphertext1)
            msg2 = decrypt(seed, ciphertext2)

            # Verify our known plaintext appears in msg1
            if msg1[position:position + len(known_plaintext)] == known_plaintext:
                print("âœ“ Verification successful - known plaintext found at expected position")
                return msg1, msg2
            else:
                print("âœ— Verification failed - known plaintext not found")
                return b"", b""

        except Exception as e:
            print(f"Recovery failed: {e}")
            return b"", b""
    else:
        # TODO: Implement message recovery using recover_seed
        #   - Call recover_seed to get the original seed
        #   - Use decrypt to get both messages
        #
        # Hints:
        # 1. Call recover_seed(ciphertext1, known_plaintext, position) to get the original seed
        # 2. Use decrypt(seed, ciphertext1) and decrypt(seed, ciphertext2) to decrypt both messages
        # 3. Verify that known_plaintext appears in msg1 at the expected position:
        #    msg1[position:position+len(known_plaintext)] == known_plaintext
        # 4. Return (msg1, msg2) if successful, or (b"", b"") if verification fails
        pass


# Perform the full attack
print("\nPerforming full message recovery...")
recovered_msg1, recovered_msg2 = recover_messages(
    ciphertext1, ciphertext2,
    b"linear congruential generator",
    correct_position
)

if recovered_msg1 and recovered_msg2:
    print("\n" + "=" * 60)
    print("RECOVERED MESSAGES:")
    print("\nMessage 1:")
    print(recovered_msg1.decode())
    print("\nMessage 2:")
    print(recovered_msg2.decode())
    print("\n" + "=" * 60)
else:
    print("\nMessage recovery failed!")

# %%
"""
## Summary: What We've Learned

Through this crib-dragging attack, we've demonstrated several critical points:

1. **Key Reuse is Fatal**: Using the same keystream to encrypt multiple messages completely breaks the security of a stream cipher.

2. **Known Plaintext is Powerful**: Even knowing a small fragment like "linear congruential generator" allowed us to:
   - Find where it appears in the message
   - Recover part of the keystream
   - Eventually decrypt both entire messages

3. **LCGs are Cryptographically Weak**: We could recover the internal state from just a few output bytes, showing why LCGs should never be used for cryptography.

4. **Real-World Implications**:
   - WEP (the old WiFi security protocol) was broken partly due to key reuse
   - Many amateur cryptographic implementations fail due to PRNG weaknesses
   - This is why modern stream ciphers use nonces to ensure unique keystreams

### Preventing These Attacks

Modern cryptographic practice prevents these attacks by:
- **Never reusing keys**: Use unique keys or nonces for each message
- **Using cryptographic PRNGs**: Like ChaCha20's generator or AES-CTR
- **Making state recovery infeasible**: Using large states and non-linear operations
- **Authenticated encryption**: Adding integrity checks to detect tampering

Remember: Don't roll your own crypto! Use well-vetted libraries like `cryptography` in Python.
"""

# %%
"""
### Stretch: Automated Crib-Dragging

Try implementing an automated crib-dragging tool that:
1. Takes a dictionary of common words/phrases (e.g., /usr/dict/words)
2. Tries each one at every position
3. Scores results based on how "readable" the recovered text is
4. Automatically finds the most likely plaintexts

This is how many real cryptanalysis tools work!
"""


def automated_crib_drag(ct1: bytes, ct2: bytes, wordlist: list[str]) -> dict:
    """
    Automated crib-dragging with multiple candidate words.

    Args:
        ct1, ct2: The two ciphertexts
        wordlist: List of potential cribs to try

    Returns:
        Dictionary of findings with confidence scores
    """
    if "SOLUTION":
        # This is left as an exercise, but here's a skeleton:
        xor_texts = bytes(c1 ^ c2 for c1, c2 in zip(ct1, ct2))
        findings = {}

        for word in wordlist:
            crib = word.encode()
            for pos in range(len(xor_texts) - len(crib) + 1):
                recovered = bytes(crib[i] ^ xor_texts[pos + i] for i in range(len(crib)))

                # Score based on printable characters
                score = sum(1 for b in recovered if 32 <= b <= 126) / len(recovered)

                if score > 0.8:  # High confidence
                    findings[f"{word}@{pos}"] = {
                        "crib": word,
                        "position": pos,
                        "recovered": recovered.decode('ascii', errors='replace'),
                        "score": score
                    }

        return findings
    else:
        # Left as an exercise for the reader!
        # Hints:
        # - Try each word at each position
        # - Score based on percentage of printable characters
        # - Look for common English letter frequencies
        # - Check for common bigrams like "th", "he", "in"
        pass

# %%
"""
# 2. Block Ciphers: DES

In this section, you will implement a simpler version of the DES (Data Encryption Standard) block cipher, which is a classic example of a Feistel cipher. DES was widely used for data encryption until it was superseded by AES (Advanced Encryption Standard).

## Introduction

Feistel ciphers are a fundamental design structure for many block ciphers, introduced by Horst Feistel at IBM in the early 1970s.
The key innovation of a Feistel network is its elegant approach to creating a reversible encryption function from any arbitrary function.
In a Feistel cipher, the input block is split into two halves (left and right).
Through multiple rounds, the right half is passed through a round function (typically involving the round key) and the output is XORed with the left half.
The halves are then swapped for the next round.
This structure makes it so that decryption uses the exact same algorithm as encryption, just with the round keys applied in reverse order.
The round function itself doesn't need to be reversible, which provides great flexibility in design.
The security of a Feistel cipher comes from using many rounds - typically 16 or more - which creates a complex relationship between the plaintext and ciphertext that resists cryptanalysis.

The Data Encryption Standard (DES) is perhaps the most famous implementation of a Feistel cipher and served as the de facto encryption standard from 1977 until the early 2000s.
DES operates on 64-bit blocks using a 56-bit key (though often represented as 64 bits with parity bits) and performs 16 rounds of encryption.
Each round uses a 48-bit subkey derived from the main key through a process called key scheduling.
The heart of DES is its f-function, which expands the 32-bit half-block to 48 bits, XORs it with the round key, and then passes it through eight S-boxes (substitution boxes) that provide the crucial non-linearity needed for security.
While DES was remarkably resilient to cryptanalysis for decades, its 56-bit key size eventually became vulnerable to brute-force attacks as computing power increased.
This led to Triple DES (3DES) as a stopgap measure, and ultimately to the adoption of AES as the new standard.

![DES image from wikipedia](https://en.wikipedia.org/wiki/File:Data_Encription_Standard_Flow_Diagram.svg)

In this exercise, you will implement a simplified version of DES to understand its structure and components, including the key schedule, initial permutation, expansion/permutation, S-boxes, and the Feistel function.
You will also implement 2DES and an attack that demonstrates why doubling the rounds does not double the security.

### DES Components

- **Initial Permutation (IP)**: Rearranges input bits
- **Expansion/Permutation (E/P)**: Expands 4 bits to 8 bits
- **S-boxes**: Non-linear substitution providing confusion
- **P4 Permutation**: Diffuses S-box outputs
- **Key Schedule**: Derives two 8-bit subkeys from the 10-bit main key
"""
import random
from typing import List, Tuple

_params_rng = random.Random(0)
P10 = list(range(10))
_params_rng.shuffle(P10)

_p8_idx = list(range(10))
_params_rng.shuffle(_p8_idx)
P8 = _p8_idx[:8]

IP = list(range(8))
_params_rng.shuffle(IP)
IP_INV = [IP.index(i) for i in range(8)]

EP = [_params_rng.randrange(4) for _ in range(8)]
P4 = list(range(4))
_params_rng.shuffle(P4)

S0 = [[_params_rng.randrange(4) for _ in range(4)] for _ in range(4)]
S1 = [[_params_rng.randrange(4) for _ in range(4)] for _ in range(4)]


# %%
"""
## Exercise 2.1: Understanding Permutations and Expansions

Permutations and expansions are fundamental operations in DES. A permutation rearranges bits, while an expansion duplicates some bits to create a larger output.

### Exercise - implement permute

> **Difficulty**: ðŸ”´ðŸ”´âšªâšªâšª  
> **Importance**: ðŸ”µðŸ”µðŸ”µðŸ”µðŸ”µ
> 
> You should spend up to ~15 minutes on this exercise.

Implement the `permute` function that applies a permutation table to a value.
"""


def permute_expand(value: int, table: List[int], in_width: int) -> int:
    """
    Apply a permutation table to rearrange bits. Note that the bits are numbered from left to right (MSB first).

    Args:
        value: Integer containing the bits to permute
        table: List where table[i] is the source position for output bit i
        in_width: Number of bits in the input value

    Returns:
        Integer with bits rearranged according to table

    Example:
        permute(0b1010, [2, 0, 3, 1], 4) = 0b1100
        Because:
        - Output bit 0 comes from input bit 2 (which is 1)
        - Output bit 1 comes from input bit 0 (which is 1)
        - Output bit 2 comes from input bit 3 (which is 0)
        - Output bit 3 comes from input bit 1 (which is 0)
    """
    if "SOLUTION":
        out = 0
        for i, src in enumerate(table):
            # Extract bit from source position
            bit = (value >> (in_width - 1 - src)) & 1
            # Place it at destination position
            out |= bit << (len(table) - 1 - i)
        return out
    else:
        # TODO: Implement permutation
        #    - For each position i in the output
        #    - Get the source bit position from table[i]
        #    - Extract that bit from the input
        #    - Place it at position i in the output
        pass


"""
<details>
<summary>Hints</summary>
Start with `out = 0`, then for each output position:
1. Find which input bit should go there (from the table)
2. Extract that bit from the input
3. OR it into the output at the correct position
</details>
"""


def test_permute(permute):
    """Test the permutation function."""
    print("Testing permutation...")

    # Test 1: Identity permutation
    identity = list(range(8))
    assert permute(0b10110011, identity, 8) == 0b10110011, "Identity permutation failed"

    # Test 2: Reverse permutation
    reverse = list(range(7, -1, -1))
    assert permute(0b10000000, reverse, 8) == 0b00000001, "Reverse permutation failed"
    assert permute(0b11110000, reverse, 8) == 0b00001111, "Reverse permutation failed"

    # Test 3: Expansion permutation (E/P in DES)
    # This duplicates some bits
    expansion = [3, 0, 1, 2, 1, 2, 3, 0]  # 4 bits â†’ 8 bits
    result = permute(0b1010, expansion, 4)
    print(f"Expansion of 0b1010: 0b{result:08b}")
    assert result == 0b01010101, "Expansion permutation failed"

    # Test 4: Compression permutation (P6 in DES)
    # This selects a subset of bits
    compression = [1, 3, 4, 6, 7, 9]  # 10 bits â†’ 6 bits (select 6 from 10)
    result = permute(0b1010101010, compression, 10)
    print(f"Compression of 0b1010101010: 0b{result:06b}")
    assert result == 0b001100, "Compression permutation failed"

    print("âœ“ Permutation tests passed!\n" + "=" * 60)


# Run the test
test_permute(permute_expand)
# %%
"""
## Exercise 2.2: Key Schedule - Generating Subkeys

The key schedule derives two 8-bit subkeys from the 10-bit main key. This process involves:
1. Initial permutation (P10)
2. Splitting into two 5-bit halves
3. Left circular shifts
4. Selection permutation (P8)

The circular shift is crucial - it ensures all key bits influence both subkeys.

### Exercise - implement key_schedule

> **Difficulty**: ðŸ”´ðŸ”´ðŸ”´âšªâšª  
> **Importance**: ðŸ”µðŸ”µðŸ”µðŸ”µâšª
> 
> You should spend up to ~20 minutes on this exercise.

Implement the key schedule function.
"""

def key_schedule(key: int, p10: List[int], p8: List[int]) -> Tuple[int, int]:
    """
    Generate two 8-bit subkeys from a 10-bit key.

    Process:
    1. Apply P10 permutation to the key
    2. Split into left (5 bits) and right (5 bits) halves
    3. Circular left shift both halves by 1
    4. Combine the halves and apply P8 to get K1
    5. Circular left shift both halves (from before P8) by 2 more (total shift of 3)
    6. Combine and apply P8 to get K2

    Args:
        key: 10-bit encryption key
        p10: Initial permutation table (10 â†’ 10 bits)
        p8: Selection permutation table (10 â†’ 8 bits)

    Returns:
        Tuple of (K1, K2) - the two 8-bit subkeys
    """
    if "SOLUTION":
        def left_shift(value: int, n: int, width: int) -> int:
            n %= width  # Handle shifts larger than width
            mask = (1 << width) - 1
            # Shift left and mask to width, OR with wrapped bits
            return ((value << n) & mask) | (value >> (width - n))

        # Step 1: Initial permutation
        perm = permute_expand(key, p10, 10)

        # Step 2: Split into halves
        left = perm >> 5  # Upper 5 bits
        right = perm & 0x1F  # Lower 5 bits (0x1F = 0b11111)

        # Step 3: First shift (LS-1)
        left = left_shift(left, 1, 5)
        right = left_shift(right, 1, 5)

        # Step 4: Generate K1
        k1 = permute_expand((left << 5) | right, p8, 10)

        # Step 5: Second shift (LS-2, total LS-3)
        left = left_shift(left, 2, 5)
        right = left_shift(right, 2, 5)

        # Step 6: Generate K2
        k2 = permute_expand((left << 5) | right, p8, 10)

        return k1, k2
    else:
        # TODO: Implement key schedule
        #    - Apply P10 permutation
        #    - Split into 5-bit halves
        #    - Generate K1 after left shift by 1 (LS-1)
        #    - Generate K2 after left shift by 2 (LS-2, total LS-3)
        #    - you might want to implement left_shift as a helper function
        pass

def test_key_schedule(key_schedule, P10, P8):
    """Test the key schedule functions."""
    print("Testing key schedule...")

    # Test key schedule with known values
    # Test key: 0b1010000010
    test_key = 0b1010000010
    k1, k2 = key_schedule(test_key, P10, P8)
    print(f"Key: 0b{test_key:010b}")
    print(f"K1:  0b{k1:08b}")
    print(f"K2:  0b{k2:08b}")

    # Verify subkeys are different
    assert k1 != k2, "Subkeys should be different"

    # Test with all-zero key
    k1_zero, k2_zero = key_schedule(0, P10, P8)
    assert k1_zero == k2_zero == 0, "All-zero key should produce all-zero subkeys"

    # Test with all-one key
    k1_ones, k2_ones = key_schedule(0b1111111111, P10, P8)
    print(f"\nAll-ones key subkeys: K1=0b{k1_ones:08b}, K2=0b{k2_ones:08b}")

    print("âœ“ Key schedule tests passed!\n" + "=" * 60)


# Run the test
test_key_schedule(key_schedule, P10, P8)

# %%
"""
## Exercise 2.3: The Feistel Function (fk)

The heart of DES is the Feistel function, which combines expansion, S-box substitution, and permutation. This function provides both confusion (S-boxes) and diffusion (permutations).

The Feistel function processes the right half of the data:
1. Expand 4 bits to 8 bits using E/P
2. XOR with the round subkey
3. Split into two 4-bit halves
4. Apply S-box substitution to each half
5. Combine and permute with P4
6. XOR result with the left half

### Exercise - implement sbox_lookup and fk

> **Difficulty**: ðŸ”´ðŸ”´ðŸ”´ðŸ”´âšª  
> **Importance**: ðŸ”µðŸ”µðŸ”µðŸ”µðŸ”µ
> 
> You should spend up to ~25 minutes on this exercise.

Implement the S-box lookup and Feistel function.
"""


def sbox_lookup(sbox: List[List[int]], bits: int) -> int:
    """
    Look up a value in an S-box.

    DES S-boxes are 4x4 tables accessed by:
    - Row: bit 0 (MSB) and bit 3 (LSB) form a 2-bit row index
    - Column: bits 1 and 2 form a 2-bit column index

    Args:
        sbox: 4x4 table of 2-bit values
        bits: 4-bit input (only lower 4 bits used)

    Returns:
        2-bit output from S-box

    Example:
        For input 0b1010:
        - Row = b0,b3 = 1,0 = 2
        - Col = b1,b2 = 0,1 = 1
        - Output = sbox[2][1]
    """
    if "SOLUTION":
        # Extract row from bits 0 and 3
        row = ((bits >> 3) & 1) << 1 | (bits & 1)
        # Extract column from bits 1 and 2
        col = ((bits >> 2) & 1) << 1 | ((bits >> 1) & 1)
        return sbox[row][col]
    else:
        # TODO: Implement S-box lookup
        pass


def fk(left: int, right: int, subkey: int, ep: List[int], s0: List[List[int]],
       s1: List[List[int]], p4: List[int]) -> Tuple[int, int]:
    """
    Apply the Feistel function to one round of DES.

    Process:
    1. Expand right half from 4 to 8 bits using E/P
    2. XOR with subkey
    3. Split into two 4-bit halves
    4. Apply S0 to left half, S1 to right half
    5. Combine S-box outputs and permute with P4
    6. XOR result with left half

    Args:
        left: 4-bit left half
        right: 4-bit right half
        subkey: 8-bit round key
        ep: Expansion permutation table (4 â†’ 8 bits)
        s0: First S-box (4x4)
        s1: Second S-box (4x4)
        p4: Final permutation (4 â†’ 4 bits)

    Returns:
        Tuple of (new_left, right) - right is unchanged
    """
    if "SOLUTION":
        # Step 1: Expand right half
        expanded = permute_expand(right, ep, 4)

        # Step 2: XOR with subkey
        expanded ^= subkey

        # Step 3: Split for S-boxes
        left_half = expanded >> 4  # Upper 4 bits
        right_half = expanded & 0xF  # Lower 4 bits

        # Step 4: S-box substitution
        s0_out = sbox_lookup(s0, left_half)
        s1_out = sbox_lookup(s1, right_half)

        # Step 5: Combine and permute
        combined = (s0_out << 2) | s1_out  # S0 output is upper 2 bits
        p4_out = permute_expand(combined, p4, 4)

        # Step 6: XOR with left half
        new_left = left ^ p4_out

        return new_left, right
    else:
        # TODO: Implement Feistel function
        #    - Expand right using E/P
        #    - XOR with subkey
        #    - Apply S-boxes to each half
        #    - Combine outputs and apply P4
        #    - XOR with left to get new left
        pass

def test_feistel(sbox_lookup, fk, EP, S0, S1, P4):
    """Test the Feistel function components."""
    print("Testing Feistel function...")

    # Test S-box lookup
    # Test all possible 4-bit inputs
    print("S-box S0:")
    for i in range(16):
        result = sbox_lookup(S0, i)
        if i % 4 == 0:
            print()
        print(f"  {i:2d} â†’ {result}", end="")
    print("\n")

    # Test Feistel function
    left = 0b1100
    right = 0b0110
    subkey = 0b10101010

    new_left, new_right = fk(left, right, subkey, EP, S0, S1, P4)

    print(f"Input:  L={left:04b}, R={right:04b}")
    print(f"Subkey: {subkey:08b}")
    print(f"Output: L={new_left:04b}, R={new_right:04b}")

    # Verify right half unchanged
    assert new_right == right, "Right half should not change"

    # Test with different inputs
    test_cases = [
        (0b0000, 0b0000, 0b00000000),
        (0b1111, 0b1111, 0b11111111),
        (0b1010, 0b0101, 0b11001100),
    ]

    print("\nAdditional test cases:")
    for l, r, k in test_cases:
        nl, nr = fk(l, r, k, EP, S0, S1, P4)
        print(f"  fk({l:04b}, {r:04b}, {k:08b}) = ({nl:04b}, {nr:04b})")

    print("âœ“ Feistel function tests passed!\n" + "=" * 60)


# Run the test
test_feistel(sbox_lookup, fk, EP, S0, S1, P4)

# %%
"""
## Exercise 2.4: Complete DES Encryption

Now let's put it all together! DES encryption consists of:
1. Initial permutation (IP)
2. First Feistel round with K1
3. Swap halves
4. Second Feistel round with K2
5. Final permutation (IPâ»Â¹)

Remember - in feistel networks, decryption uses the same algorithm with subkeys in reverse order!

### Exercise - implement process_byte

> **Difficulty**: ðŸ”´ðŸ”´ðŸ”´âšªâšª  
> **Importance**: ðŸ”µðŸ”µðŸ”µðŸ”µðŸ”µ
> 
> You should spend up to ~20 minutes on this exercise.

Implement the complete DES encryption/decryption for a single byte.
"""


def encrypt_byte(byte: int, k1: int, k2: int, ip: List[int], ip_inv: List[int],
                 ep: List[int], s0: List[List[int]], s1: List[List[int]],
                 p4: List[int]) -> int:
    """
    Encrypt or decrypt a single byte using DES.

    For encryption: use (k1, k2)
    For decryption: use (k2, k1) - reversed order!

    Process:
    1. Apply initial permutation (IP)
    2. Split into 4-bit halves
    3. Apply fk with first key
    4. Swap halves
    5. Apply fk with second key
    6. Combine halves and apply IPâ»Â¹

    Args:
        byte: 8-bit value to process
        k1: First subkey (8 bits)
        k2: Second subkey (8 bits)
        ip: Initial permutation table
        ip_inv: Inverse initial permutation table
        ep: Expansion permutation for fk
        s0, s1: S-boxes for fk
        p4: Permutation for fk

    Returns:
        8-bit processed value
    """
    if "SOLUTION":
        # Step 1: Initial permutation
        bits = permute_expand(byte, ip, 8)

        # Step 2: Split into halves
        left = bits >> 4  # Upper 4 bits
        right = bits & 0xF  # Lower 4 bits

        # Step 3: First round
        left, right = fk(left, right, k1, ep, s0, s1, p4)

        # Step 4: Swap
        left, right = right, left

        # Step 5: Second round
        left, right = fk(left, right, k2, ep, s0, s1, p4)

        # Step 6: Combine and final permutation
        combined = (left << 4) | right
        result = permute_expand(combined, ip_inv, 8)

        return result
    else:
        # TODO: Implement DES encryption/decryption
        #    - Apply IP
        #    - Two rounds with swap in between
        #    - Apply IPâ»Â¹
        #    - Same function for encrypt/decrypt!
        pass


def des_encrypt(key: int, plaintext: bytes) -> bytes:
    """Encrypt bytes using DES"""
    k1, k2 = key_schedule(key, P10, P8)
    return bytes(encrypt_byte(b, k1, k2, IP, IP_INV, EP, S0, S1, P4) for b in plaintext)


def des_decrypt(key: int, ciphertext: bytes) -> bytes:
    """Decrypt bytes using DES."""
    k1, k2 = key_schedule(key, P10, P8)
    # Note: reversed key order for decryption!
    return bytes(encrypt_byte(b, k2, k1, IP, IP_INV, EP, S0, S1, P4) for b in ciphertext)


def test_des_complete(process_byte, encrypt, decrypt, key_schedule, P10, P8, IP, IP_INV, EP, S0, S1, P4):
    """Test complete DES encryption/decryption."""
    print("Testing complete DES...")


    # Test single byte encryption/decryption
    key = 0b1010000010
    k1, k2 = key_schedule(key, P10, P8)

    plaintext = 0b11010111
    ciphertext = process_byte(plaintext, k1, k2, IP, IP_INV, EP, S0, S1, P4)
    decrypted = process_byte(ciphertext, k2, k1, IP, IP_INV, EP, S0, S1, P4)

    print(f"Key:        0b{key:010b}")
    print(f"Plaintext:  0b{plaintext:08b}")
    print(f"Ciphertext: 0b{ciphertext:08b}")
    print(f"Decrypted:  0b{decrypted:08b}")

    assert decrypted == plaintext, "Decryption failed"

    # Test full message
    message = b"Hello!"
    encrypted = encrypt(key, message)
    decrypted = decrypt(key, encrypted)

    print(f"\nMessage:   {message}")
    print(f"Encrypted: {encrypted.hex()}")
    print(f"Decrypted: {decrypted}")

    assert decrypted == message, "Message decryption failed"

    # Test avalanche effect
    key2 = key ^ 1  # Flip one bit in key
    encrypted2 = encrypt(key2, message)
    diff_bytes = sum(1 for a, b in zip(encrypted, encrypted2) if a != b)
    print(f"\nAvalanche: {diff_bytes}/{len(message)} bytes changed with 1-bit key difference")

    print("âœ“ DES tests passed!\n" + "=" * 60)


# Run the test
test_des_complete(encrypt_byte, des_encrypt, des_decrypt, key_schedule, P10, P8, IP, IP_INV, EP, S0, S1, P4)

# %%
"""
## Exercise 2.5: Meet-in-the-Middle Attack on Double DES

When DES is applied twice with different keys (Double DES), you might expect 2Â²â° = 1,048,576 possible key combinations. However, the meet-in-the-middle attack reduces this to about 2Â¹Â¹ = 2,048 operations!

The attack works by:
1. Encrypting the plaintext with all possible first keys
2. Decrypting the ciphertext with all possible second keys
3. Finding where these meet in the middle

This demonstrates why simply applying a cipher multiple times doesn't necessarily multiply the security.

### Exercise - implement meet_in_the_middle_attack

> **Difficulty**: ðŸ”´ðŸ”´ðŸ”´ðŸ”´ðŸ”´  
> **Importance**: ðŸ”µðŸ”µðŸ”µðŸ”µðŸ”µ
> 
> You should spend up to ~30 minutes on this exercise.

Implement the meet-in-the-middle attack on Double DES.
"""


def double_encrypt(key1: int, key2: int, plaintext: bytes) -> bytes:
    """Encrypt twice with different keys."""
    temp = des_encrypt(key1, plaintext)
    return des_encrypt(key2, temp)


def double_decrypt(key1: int, key2: int, ciphertext: bytes) -> bytes:
    """Decrypt twice with different keys (reverse order)."""
    temp = des_decrypt(key2, ciphertext)
    return des_decrypt(key1, temp)


def meet_in_the_middle_attack(plaintext: bytes, ciphertext: bytes) -> List[Tuple[int, int]]:
    """
    Find all key pairs (k1, k2) such that:
    double_encrypt(k1, k2, plaintext) == ciphertext

    Strategy:
    1. Build table: for each k1, compute encrypt(k1, plaintext)
    2. For each k2, compute decrypt(k2, ciphertext)
    3. If decrypt(k2, ciphertext) is in our table, we found a match!

    Args:
        plaintext: Known plaintext
        ciphertext: Corresponding ciphertext from double encryption

    Returns:
        List of (key1, key2) pairs that work
    """
    if "SOLUTION":
        # Step 1: Build forward table
        # Maps intermediate ciphertext to list of keys that produce it
        forward_table = {}

        for k1 in range(1024):  # 10-bit keys: 0 to 1023
            intermediate = des_encrypt(k1, plaintext)
            # Convert bytes to int for use as dict key
            intermediate_int = int.from_bytes(intermediate, 'big')

            if intermediate_int not in forward_table:
                forward_table[intermediate_int] = []
            forward_table[intermediate_int].append(k1)

        # Step 2: Check backward decryptions
        valid_pairs = []

        for k2 in range(1024):
            intermediate = des_decrypt(k2, ciphertext)
            intermediate_int = int.from_bytes(intermediate, 'big')

            # Check if this intermediate value is in our table
            if intermediate_int in forward_table:
                # Found match(es)!
                for k1 in forward_table[intermediate_int]:
                    valid_pairs.append((k1, k2))

        return valid_pairs
    else:
        # TODO: Implement meet-in-the-middle attack
        #    - Build table of all encrypt(k1, plaintext)
        #    - For each k2, check if decrypt(k2, ciphertext) is in table
        #    - Return all matching (k1, k2) pairs
        pass


"""
<details>
<summary>Hint 1: Building the forward table</summary>

Use a dictionary to map intermediate values to keys:
```python
forward_table = {}
for k1 in range(1024):
    intermediate = encrypt(k1, plaintext)
    # Store k1 values that produce this intermediate
```

Remember to handle bytes â†’ int conversion for dict keys.
</details>
"""


def test_meet_in_the_middle(meet_in_the_middle_attack, double_encrypt):
    """Test the meet-in-the-middle attack."""
    print("Testing meet-in-the-middle attack on Double DES...")

    import random
    import time

    # Use smaller keys for faster testing
    random.seed(42)
    key1 = random.randrange(0, 1024)
    key2 = random.randrange(0, 1024)

    print(f"True keys: k1={key1}, k2={key2}")

    # Create known plaintext-ciphertext pair
    plaintext = b"Attack!"
    ciphertext = double_encrypt(key1, key2, plaintext)

    print(f"Plaintext:  {plaintext}")
    print(f"Ciphertext: {ciphertext.hex()}")

    # Perform attack
    print("\nPerforming meet-in-the-middle attack...")
    start_time = time.time()
    found_keys = meet_in_the_middle_attack(plaintext, ciphertext)
    attack_time = time.time() - start_time

    print(f"Attack completed in {attack_time:.2f} seconds")
    print(f"Found {len(found_keys)} valid key pair(s)")

    # Check if true keys were found
    true_found = False
    for k1, k2 in found_keys[:5]:  # Show first 5
        is_true = (k1 == key1 and k2 == key2)
        marker = " â† TRUE KEYS!" if is_true else ""
        print(f"  k1={k1}, k2={k2}{marker}")
        if is_true:
            true_found = True

    if len(found_keys) > 5:
        print(f"  ... and {len(found_keys) - 5} more")

    assert true_found, "Failed to find the true keys"

    # Verify all found keys work
    for k1, k2 in found_keys:
        assert double_encrypt(k1, k2, plaintext) == ciphertext, f"Invalid keys found: {k1}, {k2}"

    # Compare with brute force time (estimated)
    brute_force_ops = 1024 * 1024
    mitm_ops = 2 * 1024
    print(f"\nComplexity reduction: {brute_force_ops:,} â†’ {mitm_ops:,} operations")
    print(f"Speedup factor: {brute_force_ops / mitm_ops:.0f}x")

    print("âœ“ Meet-in-the-middle attack succeeded!\n" + "=" * 60)


# Run the test
test_meet_in_the_middle(meet_in_the_middle_attack, double_encrypt)
"""
# 3. Block Ciphers: Substitution-Permutation Networks

In this section, you'll implement a simplified block cipher based on the Substitution-Permutation Network (SPN) structure. You will continue on the work started in the previous section, where you learned about S-boxes and P-boxes, and build AES, which is the most widely used block cipher today. This exercise will help you understand the fundamental concepts of block ciphers, including confusion, diffusion, and key scheduling.

## Introduction

The Advanced Encryption Standard (AES) is a symmetric block cipher that replaced DES as the encryption standard in 2001.
Unlike DES's Feistel structure, AES uses a substitution-permutation network (SPN) that operates on the entire data block in each round rather than just half.
AES processes data in 128-bit blocks and supports three key sizes: 128, 192, and 256 bits, with 10, 12, and 14 rounds respectively.
Each round (except the last) consists of four operations: SubBytes (byte substitution using S-boxes), ShiftRows (cyclical shifting of rows), MixColumns (mixing data within columns), and AddRoundKey (XORing with the round key).
The design philosophy emphasizes algebraic simplicity and efficiency, with operations carefully chosen to provide strong diffusion and confusion while being implementable in both hardware and software.

![Wikipedia image for AES](https://en.wikipedia.org/wiki/File:AES_(Rijndael)_Round_Function.png)

### Key Properties of Secure Block Ciphers

1. **Confusion**: The relationship between key and ciphertext should be complex and non-linear
2. **Diffusion**: Each bit of plaintext should affect many bits of ciphertext
3. **Avalanche effect**: Small changes in input should cause large changes in output
4. **Key size**: Must be large enough to prevent brute-force attacks (128+ bits)
5. **Block size**: Should be large enough to prevent birthday attacks (128+ bits)

<details>
<summary>Vocabulary: Cryptographic Terms</summary>

- **S-box (Substitution box)**: A non-linear transformation that substitutes input bits with output bits, providing confusion
- **P-box (Permutation box)**: A transformation that rearranges bit positions, providing diffusion
- **SPN (Substitution-Permutation Network)**: A cipher structure alternating substitution and permutation layers
- **Round key**: A subkey derived from the main key, used in each round of encryption
- **Confusion**: Making the relationship between key and ciphertext as complex as possible
- **Diffusion**: Spreading the influence of plaintext bits throughout the ciphertext
- **Block cipher modes**: Methods for encrypting data larger than one block (ECB, CBC, CTR, etc.)

</details>
"""
# %%
"""
## Exercise 3.1: Implementing S-box Substitution

S-boxes (Substitution boxes) are a fundamental component of block ciphers that provide non-linearity and confusion. They work by substituting small blocks of bits according to a predefined lookup table.

In our toy cipher, we use 4-bit S-boxes (16 possible inputs â†’ 16 outputs). The 16-bit block is divided into four 4-bit nibbles, and each nibble is substituted independently.

<details>
<summary>Vocabulary: S-box Terms</summary>

- **Nibble**: A 4-bit value (half a byte), can represent values 0-15
- **Non-linearity**: The property that output bits don't have a simple linear relationship with input bits
- **Lookup table**: An array where the index is the input and the value is the output
- **Bit extraction**: Using shifts (>>) and masks (&) to isolate specific bits
- **Bit packing**: Using OR (|) and shifts (<<) to combine bits into a larger value

</details>

### Exercise - implement substitute (# fixme: merge with previous exercise)

> **Difficulty**: ðŸ”´ðŸ”´âšªâšªâšª  
> **Importance**: ðŸ”µðŸ”µðŸ”µðŸ”µâšª
> 
> You should spend up to ~15 minutes on this exercise.

Implement the `substitute` function that applies S-box substitution to a 16-bit value.
"""

from typing import List
import random

def _generate_sbox(seed: int = 1):
    rng = random.Random(seed)
    sbox = list(range(16))
    rng.shuffle(sbox)
    inv = [0]*16
    for i,v in enumerate(sbox):
        inv[v] = i
    return sbox, inv

SBOX, INV_SBOX = _generate_sbox()


def substitute(x: int, sbox: List[int]) -> int:
    """
    Apply S-box substitution to a 16-bit value.

    The 16-bit input is divided into four 4-bit nibbles.
    Each nibble is substituted using the provided S-box.

    Args:
        x: 16-bit integer to substitute
        sbox: List of 16 integers (0-15) defining the substitution

    Returns:
        16-bit integer after substitution
    """
    if "SOLUTION":
        out = 0
        for i in range(4):
            nib = (x >> (i * 4)) & 0xF
            out |= sbox[nib] << (i * 4)
        return out
    else:
        # TODO: Implement S-box substitution
        #    - Extract each 4-bit nibble from x
        #    - Look up the substitution for each nibble in sbox
        #    - Combine the substituted nibbles into the output
        pass


"""
<details>
<summary>Hints</summary>
1. Start with a variable `out` initialized to 0.
2. For each nibble (0 to 3):
    - Extract the nibble
    - Use the S-box to find the substituted value
    - or the substituted value into `out` at the correct position
3. Return the final `out` value.
</details>
"""


def test_substitute(substitute, SBOX):
    """Test the S-box substitution function."""
    print("Testing S-box substitution...")

    # Test 1: Identity S-box
    identity_sbox = list(range(16))
    assert substitute(0x1234, identity_sbox) == 0x1234, "Identity S-box should not change the value"

    # Test 2: Simple substitution
    simple_sbox = [15 - i for i in range(16)]  # Reverse mapping: 0â†’15, 1â†’14, etc.
    # 0x1234 has nibbles: 4, 3, 2, 1
    # After substitution: 11, 12, 13, 14 = 0xBCDE
    assert substitute(0x1234, simple_sbox) == 0xEDCB, "Simple substitution failed"

    # Test 3: Real S-box from the cipher
    result = substitute(0x5A5A, SBOX)
    print(f"S-box substitution of 0x5A5A: 0x{result:04X}")
    assert result == 0x5F5F, "Real S-box substitution failed"

    print("âœ“ S-box substitution tests passed!\n" + "=" * 60)


# Run the test
test_substitute(substitute, SBOX)

# %%
"""
## Exercise 3.2: Implementing P-box Permutation

P-boxes (Permutation boxes) provide diffusion by rearranging the bit positions. While S-boxes work on small chunks, P-boxes work on the entire block, ensuring that changes in one part affect other parts.

In our 16-bit cipher, the P-box is a list of 16 values that defines how bits are rearranged.

<details>
<summary>Vocabulary: P-box Terms</summary>

- **Bit position**: The location of a bit in a binary number (0 = rightmost)
- **Permutation**: A rearrangement where each input has exactly one output
- **Diffusion**: The property that input changes spread throughout the output
- **Bit extraction**: Reading a single bit from a specific position
- **Bit placement**: Setting a single bit at a specific position

</details>

### Exercise - implement permute

> **Difficulty**: ðŸ”´ðŸ”´ðŸ”´âšªâšª  
> **Importance**: ðŸ”µðŸ”µðŸ”µðŸ”µâšª
> 
> You should spend up to ~20 minutes on this exercise.

Implement the `permute` function that applies P-box permutation to a 16-bit value.
"""

def _generate_pbox(seed: int = 2):
    rng = random.Random(seed)
    pbox = list(range(16))
    rng.shuffle(pbox)
    inv = [0]*16
    for i,p in enumerate(pbox):
        inv[p] = i
    return pbox, inv

PBOX, INV_PBOX = _generate_pbox()

def permute(x: int, pbox: List[int]) -> int:
    """
    Apply P-box permutation to a 16-bit value.

    For each output bit position i, take the bit from input position pbox[i].

    Args:
        x: 16-bit integer to permute
        pbox: List of 16 integers (0-15) defining the permutation
              pbox[i] = j means output bit i comes from input bit j

    Returns:
        16-bit integer after permutation
    """
    if "SOLUTION":
        out = 0
        for i, p in enumerate(pbox):
            bit = (x >> (15 - p)) & 1
            out |= bit << (15 - i)
        return out
    else:
        # TODO: Implement P-box permutation
        #    - For each output position i (0 to 15)
        #    - Get the input bit from position pbox[i]
        #    - Place it at output position i
        pass


"""
<details>
<summary>Hints</summary>
1. Start with a variable `out` initialized to 0.
2. For each output position `i` (0 to 15):
    - Get the input bit from position `pbox[i]`
    - Shift it to the correct position in `out`
3. Return the final `out` value.
</details>
"""


def test_permute(permute, PBOX):
    """Test the P-box permutation function."""
    print("Testing P-box permutation...")

    # Test 1: Identity permutation
    identity_pbox = list(range(16))
    assert permute(0xABCD, identity_pbox) == 0xABCD, "Identity permutation should not change the value"

    # Test 2: Reverse permutation
    reverse_pbox = list(range(15, -1, -1))  # [15, 14, 13, ..., 1, 0]
    # This reverses all bits
    assert permute(0x8000, reverse_pbox) == 0x0001, "Reverse permutation failed for single bit"
    assert permute(0x1234, reverse_pbox) == 0x2C48, "Reverse permutation failed"

    # Test 3: Real P-box from the cipher
    result = permute(0x5555, PBOX)
    print(f"P-box permutation of 0x5555: 0x{result:04X}")

    # Test 4: Verify single bit movement
    for i in range(16):
        input_val = 1 << (15 - i)  # Single bit at position i
        output = permute(input_val, PBOX)
        # Find where the bit ended up
        for j in range(16):
            if output & (1 << (15 - j)):
                print(f"Bit {i} â†’ Bit {j}")
                break

    print("âœ“ P-box permutation tests passed!\n" + "=" * 60)


# Run the test
test_permute(permute, PBOX)

# %%
"""
## Exercise 3.3: Building the Complete Block Cipher

Now that you understand S-boxes and P-boxes, let's combine them to build a complete Substitution-Permutation Network (SPN). Our toy cipher uses two rounds of substitution and permutation, with round keys XORed at each stage:

```
Plaintext
    â†“
   XOR (key[0])
    â†“
  S-box
    â†“
  P-box
    â†“
   XOR (key[1])
    â†“
  S-box
    â†“
  P-box
    â†“
   XOR (key[2])
    â†“
Ciphertext
```

<details>
<summary>Vocabulary: Block Cipher Terms</summary>

- **Round**: One complete cycle of substitution, permutation, and key mixing
- **Round key**: A subkey derived from the main key, used in each round
- **Key schedule**: The algorithm that generates round keys from the main key
- **XOR (âŠ•)**: Exclusive OR operation, used for mixing keys with data
- **Block**: A fixed-size chunk of data (16 bits in our toy cipher)

</details>

### Exercise - implement encrypt_block and decrypt_block

> **Difficulty**: ðŸ”´ðŸ”´ðŸ”´âšªâšª  
> **Importance**: ðŸ”µðŸ”µðŸ”µðŸ”µðŸ”µ
> 
> You should spend up to ~20 minutes on this exercise.

Implement the `encrypt_block` and `decrypt_block` functions that perform the full encryption/decryption process.
"""


def round_keys(key: int) -> List[int]:
    """Generate round keys from the main key."""
    import random
    rng = random.Random(key)
    return [rng.randrange(0, 1 << 16) for _ in range(3)]


def encrypt_block(block: int, keys: List[int], sbox: List[int], pbox: List[int]) -> int:
    """
    Encrypt a single 16-bit block using the SPN cipher.

    The cipher consists of:
    1. XOR with key[0]
    2. S-box substitution
    3. P-box permutation
    4. XOR with key[1]
    5. S-box substitution
    6. P-box permutation
    7. XOR with key[2]

    Args:
        block: 16-bit integer to encrypt
        keys: List of 3 round keys
        sbox: S-box for substitution
        pbox: P-box for permutation

    Returns:
        16-bit encrypted block
    """
    if "SOLUTION":
        x = block ^ keys[0]
        x = substitute(x, sbox)
        x = permute(x, pbox)
        x = x ^ keys[1]
        x = substitute(x, sbox)
        x = permute(x, pbox)
        x = x ^ keys[2]
        return x
    else:
        # TODO: Implement the encryption algorithm
        #    - Start with XOR of block and keys[0]
        #    - Apply two rounds of S-box, P-box, and XOR
        #    - End with XOR of keys[2]
        pass


def decrypt_block(block: int, keys: List[int], inv_sbox: List[int], inv_pbox: List[int]) -> int:
    """
    Decrypt a single 16-bit block using the SPN cipher.

    Decryption reverses the encryption process:
    1. XOR with key[2]
    2. Inverse P-box permutation
    3. Inverse S-box substitution
    4. XOR with key[1]
    5. Inverse P-box permutation
    6. Inverse S-box substitution
    7. XOR with key[0]

    Args:
        block: 16-bit integer to decrypt
        keys: List of 3 round keys (same as encryption)
        inv_sbox: Inverse S-box for substitution
        inv_pbox: Inverse P-box for permutation

    Returns:
        16-bit decrypted block
    """
    if "SOLUTION":
        x = block ^ keys[2]
        x = permute(x, inv_pbox)
        x = substitute(x, inv_sbox)
        x = x ^ keys[1]
        x = permute(x, inv_pbox)
        x = substitute(x, inv_sbox)
        x = x ^ keys[0]
        return x
    else:
        # TODO: Implement the decryption algorithm
        #    - Reverse the encryption steps
        #    - Use inverse S-box and P-box
        #    - Apply keys in reverse order
        pass


def test_block_cipher(encrypt_block, decrypt_block, round_keys, SBOX, PBOX, INV_SBOX, INV_PBOX):
    """Test the block cipher encryption and decryption."""
    print("Testing block cipher...")

    # Test 1: Encrypt and decrypt should be inverses
    key = 0x1337
    keys = round_keys(key)
    plaintext = 0xBEEF

    ciphertext = encrypt_block(plaintext, keys, SBOX, PBOX)
    decrypted = decrypt_block(ciphertext, keys, INV_SBOX, INV_PBOX)

    print(f"Plaintext:  0x{plaintext:04X}")
    print(f"Ciphertext: 0x{ciphertext:04X}")
    print(f"Decrypted:  0x{decrypted:04X}")

    assert decrypted == plaintext, "Decryption failed to recover plaintext"

    # Test 2: Different keys should give different ciphertexts
    keys2 = round_keys(0xDEAD)
    ciphertext2 = encrypt_block(plaintext, keys2, SBOX, PBOX)
    assert ciphertext != ciphertext2, "Different keys should produce different ciphertexts"

    # Test 3: Avalanche effect - small change in plaintext
    plaintext2 = plaintext ^ 1  # Flip one bit
    ciphertext3 = encrypt_block(plaintext2, keys, SBOX, PBOX)
    diff_bits = bin(ciphertext ^ ciphertext3).count('1')
    print(f"\nAvalanche effect: {diff_bits} bits changed (out of 16)")
    assert diff_bits > 2, "Cipher should have good avalanche effect"

    print("âœ“ Block cipher tests passed!\n" + "=" * 60)


# Run the test
test_block_cipher(encrypt_block, decrypt_block, round_keys, SBOX, PBOX, INV_SBOX, INV_PBOX)

# %%
"""
## Exercise 3.4: Implementing ECB Mode

Electronic Codebook (ECB) mode is the simplest block cipher mode - it encrypts each block independently. While ECB has security weaknesses (it doesn't hide patterns), it's a good starting point for understanding block cipher modes.

Our implementation needs to:
1. Split the message into 16-bit blocks (2 bytes each)
2. Encrypt each block independently
3. Handle padding for the last block if needed

<details>
<summary>Vocabulary: ECB Mode Terms</summary>

- **Block cipher mode**: A method for encrypting data larger than one block
- **ECB (Electronic Codebook)**: Mode where each block is encrypted independently
- **Padding**: Adding bytes to make the message length a multiple of the block size
- **Big-endian**: Most significant byte first (used in our implementation)

</details>

### Exercise - implement encrypt and decrypt

> **Difficulty**: ðŸ”´ðŸ”´ðŸ”´ðŸ”´âšª  
> **Importance**: ðŸ”µðŸ”µðŸ”µâšªâšª
> 
> You should spend up to ~25 minutes on this exercise.

Implement the `encrypt` and `decrypt` functions that handle full messages using ECB mode.
"""


def aes_encrypt(key: int, plaintext: bytes, sbox: List[int], pbox: List[int]) -> bytes:
    """
    Encrypt a message using ECB mode with our 16-bit block cipher.

    Process:
    1. Generate round keys from the main key
    2. Pad the message if necessary (with null bytes)
    3. Split into 2-byte blocks
    4. Encrypt each block
    5. Concatenate results (truncate padding if needed)

    Args:
        key: Encryption key (used as seed for round key generation)
        plaintext: Bytes to encrypt
        sbox: S-box for substitution
        pbox: P-box for permutation

    Returns:
        Encrypted bytes (same length as plaintext)
    """
    if "SOLUTION":
        keys = round_keys(key)
        data = plaintext
        if len(data) % 2 == 1:
            data += b"\x00"

        out = bytearray()
        for i in range(0, len(data), 2):
            # Convert 2 bytes to 16-bit block (big-endian)
            block = (data[i] << 8) | data[i + 1]
            # Encrypt the block
            enc = encrypt_block(block, keys, sbox, pbox)
            # Convert back to bytes
            out.append((enc >> 8) & 0xFF)
            out.append(enc & 0xFF)

        return bytes(out)
    else:
        # TODO: Implement ECB encryption
        #    - Generate round keys using round_keys()
        #    - Handle padding if message length is odd
        #    - Process each 2-byte block
        #    - Return result truncated to original length
        pass


def aes_decrypt(key: int, ciphertext: bytes, inv_sbox: List[int], inv_pbox: List[int]) -> bytes:
    """
    Decrypt a message using ECB mode with our 16-bit block cipher.

    Process:
    1. Generate round keys from the main key
    2. Pad the ciphertext if necessary
    3. Split into 2-byte blocks
    4. Decrypt each block
    5. Concatenate results (truncate padding if needed)

    Args:
        key: Decryption key (same as encryption key)
        ciphertext: Bytes to decrypt
        inv_sbox: Inverse S-box for substitution
        inv_pbox: Inverse P-box for permutation

    Returns:
        Decrypted bytes (same length as ciphertext)
    """
    if "SOLUTION":
        keys = round_keys(key)
        data = ciphertext

        out = bytearray()
        for i in range(0, len(data), 2):
            # Convert 2 bytes to 16-bit block (big-endian)
            block = (data[i] << 8) | data[i + 1]
            # Decrypt the block
            dec = decrypt_block(block, keys, inv_sbox, inv_pbox)
            # Convert back to bytes
            out.append((dec >> 8) & 0xFF)
            out.append(dec & 0xFF)

        # Return only the original length
        if out[-1] == 0:
            # If last byte is null, truncate it
            return bytes(out[:-1])
        return bytes(out)
    else:
        # TODO: Implement ECB decryption
        #    - Similar to encryption but use decrypt_block
        #    - Remember to use inverse S-box and P-box
        pass


def test_ecb_mode(encrypt, decrypt, SBOX, PBOX, INV_SBOX, INV_PBOX):
    """Test ECB mode encryption and decryption."""
    print("Testing ECB mode...")

    # Test 1: Basic encryption/decryption
    key = 0xCAFE
    message = b"Hello, World"

    ciphertext = encrypt(key, message, SBOX, PBOX)
    decrypted = decrypt(key, ciphertext, INV_SBOX, INV_PBOX)

    print(f"Original:  {message}")
    print(f"Encrypted: {ciphertext.hex()}")
    print(f"Decrypted: {decrypted}")

    assert decrypted == message, "Decryption failed to recover message"

    # Test 2: Odd length message (tests padding)
    odd_message = b"Hello"
    ciphertext2 = encrypt(key, odd_message, SBOX, PBOX)
    decrypted2 = decrypt(key, ciphertext2, INV_SBOX, INV_PBOX)
    assert decrypted2 == odd_message, "Failed with odd-length message"

    # Test 3: ECB pattern weakness
    # Repeating blocks should encrypt to the same ciphertext
    pattern_msg = b"ABCDABCD"
    pattern_ct = encrypt(key, pattern_msg, SBOX, PBOX)
    # First 2 bytes should equal bytes 4-6, second 2 bytes should equal bytes 6-8
    assert pattern_ct[0:2] == pattern_ct[4:6], "ECB should preserve patterns"
    assert pattern_ct[2:4] == pattern_ct[6:8], "ECB should preserve patterns"

    print("âœ“ ECB mode tests passed!\n" + "=" * 60)


# Run the test
test_ecb_mode(aes_encrypt, aes_decrypt, SBOX, PBOX, INV_SBOX, INV_PBOX)


