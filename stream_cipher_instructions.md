
# Stream Ciphers and Pseudorandom Generators

## Introduction

This section is designed to get you familiar with stream ciphers and pseudorandom number generators (PRNGs). You'll implement a Linear Congruential Generator (LCG) and use it to build a simple stream cipher, understanding both how they work and why they're not suitable for real cryptographic use.

## Content & Learning Objectives

### 1ï¸âƒ£ Linear Congruential Generators

In the first exercise, you'll implement an LCG, one of the simplest pseudorandom number generators.

> **Learning Objectives**
> - Understand the mathematical foundation of pseudorandom number generators
> - Implement an LCG and use it to generate a keystream

### 2ï¸âƒ£ Building a Stream Cipher

Here, you'll use the keystream generated by the LCG to build a simple stream cipher that can encrypt and decrypt messages.

> **Learning Objectives**
> - Implement a stream ciphers work using XOR operations
> - Explore the security implications of key reuse

### 3ï¸âƒ£ Breaking a Stream Cipher

In the final exercise, you'll learn how to break a stream cipher using a technique called crib-dragging. This will help you understand the vulnerabilities of stream ciphers when keys are reused.

> **Learning Objectives**
> - Understand the vulnerabilities of stream ciphers
> - Implement a crib-dragging attack to recover plaintext from ciphertext

## Why Stream Ciphers Matter

- **Performance**: They're fast and efficient, especially for streaming data. If you need to stream data, and you do not know the length in advance, stream ciphers are ideal.
- **Simplicity**: The core concept is simple - XOR with a keystream. You just need to generate a stream of bytes that cannot be guessed.
- **Real-world usage**: Because of their performance characteristics, stream ciphers are used in protocols like TLS, WPA2, and mobile communications

### Key Properties of Secure Stream Ciphers

1. **Pseudorandomness**: The keystream should be indistinguishable from random (i.e., no patterns the attacker can predict)
2. **Long period**: The keystream shouldn't repeat for practical message lengths
3. **Key sensitivity**: Small changes in the key should produce completely different keystreams
4. **Forward secrecy**: Knowledge of some keystream bits shouldn't reveal others

<details>
<summary>Vocabulary: Cryptographic Terms</summary>

- **PRNG (Pseudorandom Number Generator)**: An algorithm that produces a sequence of numbers that appears random but is actually deterministic given an initial seed
- **Keystream**: The sequence of pseudorandom bytes generated by a stream cipher that gets XORed with the plaintext
- **One-time pad**: A theoretically unbreakable cipher where the key is truly random, as long as the message, and never reused
- **TLS (Transport Layer Security)**: The protocol that secures HTTPS connections
- **WPA2**: A security protocol for WiFi networks
- **Forward secrecy**: A property where compromise of long-term keys doesn't compromise past session keys

</details>


```python

from typing import Generator
```

## Exercise 1: Implementing a Linear Congruential Generator (LCG)

An LCG generates a sequence of numbers using the recurrence relation:
```
X_{n+1} = (a * X_n + c) mod m
```

Where:
- X_n is the current state
- a is the multiplier
- c is the increment
- m is the modulus

We'll use the parameters from Numerical Recipes (a popular choice):
- a = 1664525
- c = 1013904223
- m = 2^32

<details>
<summary>Vocabulary: LCG Terms</summary>

- **Recurrence relation**: A formula that defines each term of a sequence using previous terms
- **Modulus (m)**: The value that wraps the sequence around (like a clock with m positions)
- **Multiplier (a)**: Scales the current value before adding the increment
- **Increment (c)**: Added to ensure the sequence doesn't get stuck at zero
- **Period**: How many values the generator produces before repeating

</details>

### Exercise - implement lcg_keystream

> **Difficulty**: ðŸ”´âšªâšªâšªâšª
> **Importance**: ðŸ”µðŸ”µðŸ”µâšªâšª
>
> You should spend up to ~10 minutes on this exercise.

Implement the `lcg_keystream` function that generates a stream of bytes using the LCG algorithm.


```python


def lcg_keystream(seed: int) -> Generator[int, None, None]:
    """
    Generate an infinite keystream using a basic LCG.

    The LCG formula is: next_state = (a * current_state + c) mod m
    Where:
        - a = 1664525
        - c = 1013904223
        - m = 2^32

    Args:
        seed: Initial seed value for the generator.

    Yields:
        Bytes of the keystream as integers in range 0-255.
    """
    # TODO: Implement the LCG keystream generator
    #    - Update state using the LCG formula
    #    - Yield the lowest 8 bits of state as a byte
    pass
from w1d1.stream_cipher_test import test_lcg_keystream
test_lcg_keystream(lcg_keystream)
```

## Exercise 2: Building a Stream Cipher

Stream ciphers work by XORing the plaintext with a keystream. The encryption process is:
```
ciphertext[i] = plaintext[i] XOR keystream[i]
```

Decryption is identical:
```
plaintext[i] = ciphertext[i] XOR keystream[i]
```

This works because: `(A XOR B) XOR B = A XOR (B XOR B) = A XOR 0 = A`

<details>
<summary>Vocabulary: XOR Operation</summary>

- **XOR (Exclusive OR)**: A bitwise operation that outputs 1 when inputs differ and 0 when they're the same. Key properties:
  - `A XOR A = 0` (anything XORed with itself is zero)
  - `A XOR 0 = A` (XORing with zero leaves value unchanged)
  - `A XOR B = B XOR A` (commutative)
  - `(A XOR B) XOR B = A` (self-inverse property - crucial for stream ciphers!)

</details>

### Exercise - implement encrypt and decrypt

> **Difficulty**: ðŸ”´ðŸ”´âšªâšªâšª
> **Importance**: ðŸ”µðŸ”µðŸ”µðŸ”µâšª
>
> You should spend up to ~10 minutes on this exercise.

Implement the `encrypt` and `decrypt` functions using your LCG keystream.


```python


def encrypt(seed: int, plaintext: bytes) -> bytes:
    """
    Encrypt plaintext using the LCG keystream.

    Stream cipher encryption: ciphertext = plaintext XOR keystream

    Args:
        seed: Seed for the keystream generator.
        plaintext: Data to encrypt.

    Returns:
        Ciphertext as bytes.
    """
    # TODO: Implement stream cipher encryption
    #   - XOR each byte of plaintext with the bytes from lcg_keystream
    #   - return the resulting ciphertext as bytes
    pass
from w1d1.stream_cipher_test import test_encrypt
test_encrypt(encrypt)

# %%
def decrypt(seed: int, ciphertext: bytes) -> bytes:
    """
    Decrypt ciphertext using the same LCG keystream.

    In stream ciphers, decryption is the same operation as encryption!

    Args:
        seed: Seed for the keystream generator.
        ciphertext: Data to decrypt.

    Returns:
        Decrypted plaintext.
    """
    # TODO: Implement stream cipher decryption
    pass
from w1d1.stream_cipher_test import test_decrypt
test_decrypt(decrypt)
from w1d1.stream_cipher_test import test_stream_cipher


test_stream_cipher(lcg_keystream, encrypt, decrypt)
```

## Understanding Stream Cipher Security

Now that you've built a stream cipher, let's explore its security properties and weaknesses.

### Why LCG is Not Cryptographically Secure

While our LCG-based stream cipher works, it's not secure for cryptographic use:

1. **Predictability**: Given a few outputs, the entire sequence can be predicted
2. **Short period**: Will repeat after at most 2^32 outputs
3. **Statistical bias**: Fails statistical randomness tests
4. **State recovery**: The internal state can be recovered from outputs

<details>
<summary>Vocabulary: Cryptographic Attacks</summary>

- **State recovery attack**: An attack where the attacker determines the internal state of the PRNG from observing outputs
- **Statistical bias**: When the output distribution deviates from truly random, allowing statistical attacks
- **Cryptanalysis**: The study of analyzing and breaking cryptographic systems
- **Period**: The number of outputs before a PRNG repeats its sequence

</details>

### Real Cryptographic Stream Ciphers

Modern stream ciphers like ChaCha20 address these issues:
- Use complex non-linear operations
- Have much larger internal states
- Resist known cryptanalytic attacks
- Pass stringent randomness tests

### The Importance of Key Reuse

One critical vulnerability in stream ciphers is key reuse. If the same key (seed) is used to encrypt two different messages:

```
C1 = M1 XOR Keystream
C2 = M2 XOR Keystream

Then: C1 XOR C2 = M1 XOR M2
```

This reveals the XOR of the two plaintexts, which can often be used to recover both messages!

<details>
<summary>Vocabulary: Key Reuse Attack</summary>

- **Two-time pad**: When a one-time pad (or stream cipher key) is used twice - a critical security failure
- **Crib dragging**: A technique to recover plaintexts when you have `M1 XOR M2` by guessing common words
- **Known plaintext attack**: When an attacker knows some plaintext-ciphertext pairs
- **Malleability**: The property that allows an attacker to modify ciphertexts in predictable ways

</details>

### Next Steps

In practice, you would:
1. Use cryptographically secure PRNGs (like those in `secrets` module)
2. Never reuse keys/nonces in stream ciphers
3. Consider authenticated encryption modes
4. Use well-vetted algorithms like ChaCha20 or AES-CTR

Understanding these basic principles helps you appreciate why cryptographic primitives are designed the way they are!

<details>
<summary>Vocabulary: Advanced Cryptographic Terms</summary>

- **Nonce**: A "number used once" - a value that should never be repeated with the same key. Critical for stream cipher security
- **Authenticated encryption**: Encryption that also provides integrity checking to detect tampering
- **ChaCha20**: A modern stream cipher designed by Daniel Bernstein, used in TLS 1.3
- **AES-CTR**: AES (Advanced Encryption Standard) in Counter mode, which turns the block cipher into a stream cipher
- **Initialization Vector (IV)**: Similar to a nonce, used to ensure same plaintext encrypts differently each time

</details>


## Exercise 3: Breaking Stream Ciphers with Crib-Dragging

When a stream cipher key is reused, it becomes vulnerable to a **crib-dragging attack**. If we have two ciphertexts encrypted with the same keystream:

```
C1 = M1 XOR K
C2 = M2 XOR K
```

Then: `C1 XOR C2 = M1 XOR M2`

If we guess (or "crib") part of one message, we can recover the corresponding part of the other message!

<details>
<summary>How Crib-Dragging Works</summary>

1. We XOR the two ciphertexts to get `M1 XOR M2`
2. We guess a word or phrase that might appear in one message (the "crib")
3. We XOR this crib at different positions in `M1 XOR M2`
4. When we find the right position, we'll see readable text from the other message
5. This reveals parts of both plaintexts, which can help us guess more

</details>

### Exercise 3a: LCG State Recovery

First, let's understand how to recover the LCG seed from known keystream bytes.

> **Difficulty**: ðŸ”´ðŸ”´ðŸ”´âšªâšª
> **Importance**: ðŸ”µðŸ”µðŸ”µðŸ”µâšª
>
> You should spend up to ~15 minutes on this exercise.

Implement the `recover_lcg_state` function that recovers the seed from consecutive keystream bytes.


```python


def recover_lcg_state(keystream_bytes: list[int]) -> int:
    """
    Recover the LCG seed from consecutive keystream bytes.

    The key insight is that we observe the OUTPUT of states, not the states themselves.
    If we see byte b0, that was produced by some state s0.
    We need to find s_{-1} (the seed) such that s0 = (a * s_{-1} + c) % m and s0 & 0xFF = b0.

    Args:
        keystream_bytes: At least 2 consecutive bytes from the keystream.

    Returns:
        A seed (initial state) that generates this keystream.
    """
    if len(keystream_bytes) < 2:
        raise ValueError("Need at least 2 keystream bytes")

    a = 1664525
    c = 1013904223
    m = 2 ** 32
    # TODO: Implement LCG state recovery
    #   - brute-force through all possible upper 24 bits - this will let you try all possible starting states
    #   - for each state, check if it produces the correct bytes
    #   - if it does, calculate the seed by rearranging the LCG formula to get a formula for the seed

    # Hints:
    # 1. For each possible upper 24 bits (2^24 possibilities)
    # 2. Construct state_0 = (upper_24_bits << 8) | keystream_bytes[0]
    # 3. Check if this state produces the correct subsequent bytes
    # 4. If valid, calculate the seed using modular arithmetic
    pass
from w1d1.stream_cipher_test import test_lcg_state_recovery


test_lcg_state_recovery(lcg_keystream, recover_lcg_state)
```

### Exercise 3b: The Crib-Dragging Attack

Now let's perform a real crib-dragging attack. We have intercepted two messages encrypted with the same key. It looks like the messages are talking about LCGs and stream ciphers, so you can safely assume that the phrase "linear congruential generator" appears in one of them.


```python

# Two paragraphs about LCGs, one containing our crib
from w1d1.stream_cipher_secrets import intercept_messages
ciphertext1, ciphertext2 = intercept_messages(encrypt)
print(f"Intercepted ciphertext 1 ({len(ciphertext1)} bytes): {ciphertext1[:50].hex()}...")
print(f"Intercepted ciphertext 2 ({len(ciphertext2)} bytes): {ciphertext2[:50].hex()}...")
```

### Exercise - implement crib_drag

> **Difficulty**: ðŸ”´ðŸ”´ðŸ”´ðŸ”´âšª
> **Importance**: ðŸ”µðŸ”µðŸ”µðŸ”µðŸ”µ
>
> You should spend up to ~20 minutes on this exercise.

Implement the `crib_drag` function that tries a known plaintext fragment at different positions.


```python


def crib_drag(ciphertext1: bytes, ciphertext2: bytes, crib: bytes) -> list[tuple[int, bytes]]:
    """
    Perform crib-dragging attack on two ciphertexts encrypted with the same keystream.

    Args:
        ciphertext1: First intercepted ciphertext
        ciphertext2: Second intercepted ciphertext
        crib: Known plaintext fragment to try

    Returns:
        List of (position, recovered_text) tuples for further analysis.
    """
    # TODO: Implement crib-dragging
    #   - Use the xor_texts = C1 XOR C2 to find M1 XOR M2
    #   - For each position in xor_texts, XOR the crib with the text at that position
    #   - return a list of tuples (position, recovered_text)

    # Hint:
    # 1. Calculate xor_texts = C1 XOR C2 (which equals M1 XOR M2)
    # 2. For each position from 0 to len(xor_texts) - len(crib):
    #    a. XOR the crib with xor_texts at this position
    #    b. Check if result is readable (all bytes are printable ASCII: 32-126)
    #    c. If readable, add (position, recovered_text) to results
    # 3. Return results list
    pass
from w1d1.stream_cipher_test import test_crib_drag


correct_position = test_crib_drag(crib_drag, ciphertext1, ciphertext2)
```

### Exercise 3c: Full Message Recovery

Now that we've found where the crib appears, we can:
1. Recover part of the keystream at that position
2. Find the LCG state that produced those keystream bytes
3. Reverse the LCG to find the original seed
4. Decrypt both messages completely!

The key insight: if we know keystream bytes at position P, we can find the state that
produced them, then reverse the LCG P times to get back to the original seed.

### Exercise - implement recover_seed

> **Difficulty**: ðŸ”´ðŸ”´ðŸ”´ðŸ”´âšª
> **Importance**: ðŸ”µðŸ”µðŸ”µðŸ”µðŸ”µ
>
> You should spend up to ~15 minutes on this exercise.

First, implement `recover_seed` that finds the original seed from a known plaintext at a specific position.


```python


def recover_seed(ciphertext: bytes, known_plaintext: bytes, position: int) -> int:
    """
    Recover the original LCG seed from a known plaintext fragment at a specific position.

    This function recovers keystream bytes at the given position, finds the LCG state
    that produced them, then reverses the LCG to find the original seed.

    Args:
        ciphertext: The ciphertext containing the known plaintext
        known_plaintext: The known plaintext fragment
        position: The position where known_plaintext appears in the original message

    Returns:
        The original seed used to encrypt the message
    """
    # TODO: Implement seed recovery
    #   - Use the known plaintext to recover keystream bytes at the given position
    #   - Call recover_lcg_state(keystream_bytes) to get the seed that produces these bytes
    #   - note that the seed at this position is the same as the state - so you can reverse the LCG 'position' times to get back to the original seed
    #
    # Hints:
    # 1. Recover keystream bytes at position:
    #    keystream[i] = ciphertext[position+i] XOR known_plaintext[i]
    # 2. Call recover_lcg_state(keystream) to get the seed that produces these bytes
    # 3. Reverse the LCG 'position' times to get back to the original seed:
    #    - a_inv = pow(a, -1, m)
    #    - state = ((state - c) * a_inv) % m
    # 4. Return the original seed
    pass
from w1d1.stream_cipher_test import test_recover_seed


test_recover_seed(recover_seed, decrypt, ciphertext1, correct_position)
```

### Exercise - implement recover_messages

> **Difficulty**: ðŸ”´ðŸ”´ðŸ”´âšªâšª
> **Importance**: ðŸ”µðŸ”µðŸ”µðŸ”µðŸ”µ
>
> You should spend up to ~10 minutes on this exercise.

Now implement `recover_messages` that uses `recover_seed` to decrypt both messages.


```python


def recover_messages(ciphertext1: bytes, ciphertext2: bytes,
                     known_plaintext: bytes, position: int) -> tuple[bytes, bytes]:
    """
    Recover both messages using a known plaintext fragment.

    Args:
        ciphertext1: First ciphertext (contains known_plaintext)
        ciphertext2: Second ciphertext
        known_plaintext: Known fragment from message1
        position: Position of known_plaintext in message1

    Returns:
        Tuple of (recovered_message1, recovered_message2)
    """
    # TODO: Implement message recovery using recover_seed
    #   - Call recover_seed to get the original seed
    #   - Use decrypt to get both messages
    #
    # Hints:
    # 1. Call recover_seed(ciphertext1, known_plaintext, position) to get the original seed
    # 2. Use decrypt(seed, ciphertext1) and decrypt(seed, ciphertext2) to decrypt both messages
    # 3. Verify that known_plaintext appears in msg1 at the expected position:
    #    msg1[position:position+len(known_plaintext)] == known_plaintext
    # 4. Return (msg1, msg2) if successful, or (b"", b"") if verification fails
    pass


# Perform the full attack
print("\nPerforming full message recovery...")
recovered_msg1, recovered_msg2 = recover_messages(
    ciphertext1, ciphertext2,
    b"linear congruential generator",
    correct_position
)

if recovered_msg1 and recovered_msg2:
    print("\n" + "=" * 60)
    print("RECOVERED MESSAGES:")
    print("\nMessage 1:")
    print(recovered_msg1.decode())
    print("\nMessage 2:")
    print(recovered_msg2.decode())
    print("\n" + "=" * 60)
else:
    print("\nMessage recovery failed!")
```

## Summary: What We've Learned

Through this crib-dragging attack, we've demonstrated several critical points:

1. **Key Reuse is Fatal**: Using the same keystream to encrypt multiple messages completely breaks the security of a stream cipher.

2. **Known Plaintext is Powerful**: Even knowing a small fragment like "linear congruential generator" allowed us to:
   - Find where it appears in the message
   - Recover part of the keystream
   - Eventually decrypt both entire messages

3. **LCGs are Cryptographically Weak**: We could recover the internal state from just a few output bytes, showing why LCGs should never be used for cryptography.

4. **Real-World Implications**:
   - WEP (the old WiFi security protocol) was broken partly due to key reuse
   - Many amateur cryptographic implementations fail due to PRNG weaknesses
   - This is why modern stream ciphers use nonces to ensure unique keystreams

### Preventing These Attacks

Modern cryptographic practice prevents these attacks by:
- **Never reusing keys**: Use unique keys or nonces for each message
- **Using cryptographic PRNGs**: Like ChaCha20's generator or AES-CTR
- **Making state recovery infeasible**: Using large states and non-linear operations
- **Authenticated encryption**: Adding integrity checks to detect tampering

Remember: Don't roll your own crypto! Use well-vetted libraries like `cryptography` in Python.


### Stretch Challenge: Automated Crib-Dragging

Try implementing an automated crib-dragging tool that:
1. Takes a dictionary of common words/phrases
2. Tries each one at every position
3. Scores results based on how "readable" the recovered text is
4. Automatically finds the most likely plaintexts

This is how real cryptanalysis tools work!


```python


def automated_crib_drag(ct1: bytes, ct2: bytes, wordlist: list[str]) -> dict:
    """
    Automated crib-dragging with multiple candidate words.

    Args:
        ct1, ct2: The two ciphertexts
        wordlist: List of potential cribs to try

    Returns:
        Dictionary of findings with confidence scores
    """
    # Left as an exercise for the reader!
    # Hints:
    # - Try each word at each position
    # - Score based on percentage of printable characters
    # - Look for common English letter frequencies
    # - Check for common bigrams like "th", "he", "in"
    pass
```